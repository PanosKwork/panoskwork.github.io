<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[android]]></title>
      <url>/2017/11/04/android/</url>
      <content type="html"><![CDATA[<h1 id="Android入门基础"><a href="#Android入门基础" class="headerlink" title="Android入门基础"></a>Android入门基础</h1><hr>
<h2 id="6-数据保存"><a href="#6-数据保存" class="headerlink" title="6.数据保存"></a>6.数据保存</h2><h3 id="6-1保存到文件"><a href="#6-1保存到文件" class="headerlink" title="6.1保存到文件"></a>6.1保存到文件</h3><h4 id="存储到内部还是外部"><a href="#存储到内部还是外部" class="headerlink" title="存储到内部还是外部"></a>存储到内部还是外部</h4><p>所有的Android设备都有两个文件存储区域：“internal”和“external”</p>
<ul>
<li><p>Internal storage:</p>
<ul>
<li><p>总是可用的</p>
</li>
<li><p>这里的文件默认只能被我们的APP所访问</p>
</li>
<li><p>当用户卸载APP时，系统会把internal内该APP相关的文件都清除干净</p>
</li>
<li><p>Internal是我们在想确保不被用户与其他APP所访问的最佳存储位置</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>External storage:</p>
<ul>
<li>并不总是可用的，因为用户有时会通过USB存储模式挂载外部存储器，当取下挂载的这部分后，就无法对其进行访问了</li>
<li>是大家都可以访问的，因此保存在这里的文件可能被其他程序访问</li>
<li>当用户卸载我们的app时，系统仅仅会删除external根目录（<a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String" target="_blank" rel="external">getExternalFilesDir()</a>)）下的相关文</li>
<li>External是在不需要严格的访问权限并且希望这些文件能够被其他app所共享或者是允许用户通过电脑访问时的最佳存储区域</li>
</ul>
</li>
</ul>
<h4 id="获取External存储权限"><a href="#获取External存储权限" class="headerlink" title="获取External存储权限"></a>获取External存储权限</h4><p> <code>&lt;uses-permission android name=&quot;android.perimission.WRITE_EXTERNAL_STORAGE&quot;&gt;</code></p>
<blockquote>
<p>如果已经声明了此权限，则默认也声明了READ_EXTERNAL_STORAGE  </p>
</blockquote>
<h4 id="保存到internal-storage"><a href="#保存到internal-storage" class="headerlink" title="保存到internal storage"></a>保存到internal storage</h4><ul>
<li><p>获取目录作为FILE的对象</p>
<ul>
<li>getFileDir():返回一个File，代表了APP的internal目录</li>
<li>getCache():返回一个File,代表了APP的internal缓存目录</li>
</ul>
</li>
<li><p>执行openFileOutput()获取一个FileOutputStream用于写文件到internal目录，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FileOutputStream outputStream = openFileOutput(filename,CONTEXT.MODE_PRIVATE);</div><div class="line">outputStream.write();</div><div class="line">outputStream.close();<span class="comment">//一定记得调用close</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>利用creatTempFile()缓存文件</p>
<p><code>File file = Fiel.creatTempFile(fileName,null,context.getCacheDir());</code></p>
<p>​</p>
</li>
</ul>
<h4 id="保存文件到External-stroage"><a href="#保存文件到External-stroage" class="headerlink" title="保存文件到External stroage"></a>保存文件到External stroage</h4><ul>
<li><p>通过getExternalStorageState()检验external storage是否可用,返回MEDIA_MOUNTED则可读写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Check if ecternal storage is available for read and write</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageWriteable</span><span class="params">()</span></span>&#123;</div><div class="line">	String state = Environment.getExternalStorageState();</div><div class="line">	<span class="keyword">if</span>(Enviroment.MEDIA_MOUNTED.equals(state))&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Check if external storage is available to at least read</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageReadable</span><span class="params">()</span></span>&#123;</div><div class="line">	String state = Environment.getExternalStorageState();</div><div class="line">	<span class="keyword">if</span>(Environment.MEDIA_MOUNTED.equals(state) || </div><div class="line">	   Environment.MEDIA_MOUNTED_READ_ONLY.equals(state))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
<li><p>一般步骤</p>
<ul>
<li><p>声明读写权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name = <span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>&gt;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>动态请求权限(CompileSdkVersion在23以上的需要)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ActivityCompat.requestPermission(<span class="keyword">this</span>,<span class="keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;)</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>存储数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建文件夹</span></div><div class="line">File dir = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(),<span class="string">"skypan"</span>);</div><div class="line"><span class="keyword">if</span>(!dir.exists())&#123;</div><div class="line">  dir.mkdirs();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建文件</span></div><div class="line">File file = <span class="keyword">new</span> File(dir,fileName);</div><div class="line"><span class="keyword">if</span>(!file.exits())&#123;</div><div class="line">  file.creatNewFile();</div><div class="line">&#125;</div><div class="line">fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line"></div><div class="line"><span class="comment">//读取数据</span></div><div class="line">File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory()+File.seperator+<span class="string">"skypan"</span>,fileName);</div><div class="line">fileInputStream = <span class="keyword">new</span> FileInputStream(file);</div><div class="line"><span class="comment">//其他操作同存储数据</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>通过FileOutputStream对象构建OutputStream对象，再通过OutputStream对象构建BufferedWriter对象，最后再调用write()和close()方法</p>
</blockquote>
<ul>
<li>External Storage中文件保存类型<ul>
<li>Public files：这些文件对于用户与其他app来说都是public的，当用户卸载我们的app时，这些文件应该保留。例如，那些被我们的app拍摄的图片或者下载的文件。<ul>
<li>通过执行getExternalStoragePublicDirectory(DIRECTORY_MUSIC或者DIRCTORY_PICTURES)来获取一个File对象</li>
</ul>
</li>
<li>Private files：这些文件完全被我们的app所私有，它们应该在app被卸载时删除。尽管由于存储在external storage，那些文件从技术上而言可以被用户与其他app所访问，但实际上那些文件对于其他app没有任何意义。因此，当用户卸载我们的app时，系统会删除其下的private目录。例如，那些被我们的app下载的缓存文件。<ul>
<li>通过执行getExternalFilesDir()来获取相应的目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h4><p><strong>openFileInput()、StringBuilder()</strong></p>
<ul>
<li>通过FileInputStream对象构建InputStreamReader对象，再通过InputStreamReader对构建BufferdReader对象 </li>
<li>通过StringBuilder().append()来拼接字符串</li>
</ul>
<h3 id="6-2保存到perference"><a href="#6-2保存到perference" class="headerlink" title="6.2保存到perference"></a>6.2保存到perference</h3><h3 id="6-3保存到数据库"><a href="#6-3保存到数据库" class="headerlink" title="6.3保存到数据库"></a>6.3保存到数据库</h3><h4 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h4><p>SQLite(Structured Query Language)数据库是android系统自带的(重难点：查（query）)，主要用到的类包括SQLiteOpenHelper和SQLiteDatabase。      </p>
<ul>
<li><p>SQLiteOpenHelper：创建数据库和数据库版本管理的辅助类，该类是一个抽象类，所以我们一般都有一个子类SQLiteOpenHelper，需要继承实现的方法主要有onCreate()、onUpgrade()、getWritableDatabase()等。getWritableDatabase()方法返回的是SQLiteDatabase对象实例，如果数据库尚未创建，则会自动调用onCreate()方法来创建数据库，所以一些建表和数据初始化操作，应该放在onCreate()方法里 。 </p>
</li>
<li><p>SQLiteDatabase：操作SQLite数据库的类，可以进行SQL语句，对数据库进行增、删、改、查的操作，该对象已经对基本的数据库操作进行了封装。可以调用insert()、delete()、update()、select()等方法，进行实际的数据库操作 ，这个类相当于JDBC中的Connection，也类似Hibernate中的Session，或者Spring中的HibernateTemplate；也可以进行transaction的控制。很多对数据库的操作最终都是通过SQLiteDatabase实例来调用执行的。        注意：数据库对于一个应用时私有的，并且在一个应用当中，数据库的名字也是唯一的。</p>
<ul>
<li>insert(“Book”,null,values)     //参数1：表名；    参数2：用于在未指定添加呢数据的情况下给某些可为空的列自动赋值NULL，一般用不到，直接传入null即可；    参数3：是一个ContentValues对象，它提供了一系列的put()方法重载，用于向ContentValues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。</li>
<li>delete(“Book”,”pages &gt; ?”,new String[]{“500”})    //参数1：表名；    参数2和参数3：用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有行。此处意思为“仅删除页数超过500页的书”。</li>
<li>update(“Book”,values,”name = ?”,new String[]{“The Da Vinci code”})   //参数1：表名；  参数2和参数3：用于约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行。此处意思为(注：前文 有values.put(“price”,10.99))“将名字为The Da Vinci Code的这本书的价格改成10.99”。</li>
<li>query(table,columns,selection,selectionArgs,groupBy,having,orderBy)   //调用query()放啊发后会返回一个Cursor对象，查询到的所有数据都将从这个对象中取出</li>
</ul>
<p>| query()方法参数query()方法参数 |         对应SQL部分          |          描述描述          |<br>| :——————–: | :———————-: | :——————–: |<br>|         table          |     from table_name      |        指定查询的表名         |<br>|       columns(列)       |  select column1,column2  |        指定查询的列名         |<br>|       selection        |   where column = value   |      指定where的约束条件      |<br>|     selectionArgs      |            -             |   为where中的占位符提供具体的值    |<br>|        groupBy         |     group by column      |     指定需要group by的列     |<br>|         having         |  having column = value   | 对group by后的结果进一步约束（过滤） |<br>|        orderBy         | order by column1,column2 |      指定查询结果的排序方式       |</p>
<p>​</p>
<p>​</p>
<p>​</p>
</li>
<li><p>Corsor：游标。通过Cursor可以对于从数据库中查询出来的结果集进行随机的读写访问。对于数据库的查询结果，一般是由子类SQLiteCursor返回的。        <strong>特别注意：</strong>开发的时候一般会对前面两个类做一下包装，比如进行简单的封装，使得SQLiteDatabase的查询方法不是返回原始的Cursor类（Cursor相当于JDBC中的ResultSet），而是返回业务对象等等</p>
<p>​</p>
</li>
</ul>
<p>SQLiteOpenHelper类的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sql;</div><div class="line"><span class="keyword">import</span> android.content.Context;</div><div class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase;</div><div class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase.CursorFactory;</div><div class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteOpenHelper;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBaseHelpler</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>&#123;</div><div class="line">    <span class="comment">//数据库版本号</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION = <span class="number">1</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DataBaseHelpler</span><span class="params">(Context context, String name, CursorFactory factory,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">int</span> version)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, name, factory, version);</div><div class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DataBaseHelpler</span><span class="params">(Context context,String name)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>(context,name,VERSION);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DataBaseHelpler</span><span class="params">(Context context, String name,<span class="keyword">int</span> version)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>(context, name, <span class="keyword">null</span>, version);</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    System.out.println(<span class="string">"creat database"</span>);</div><div class="line">    db.execSQL(<span class="string">"create table student(no int,name verchar(20))"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    System.out.println(<span class="string">"upgrade database"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SQLite类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sql;</div><div class="line"><span class="keyword">import</span> android.app.Activity;</div><div class="line"><span class="keyword">import</span> android.content.ContentValues;</div><div class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase;</div><div class="line"><span class="keyword">import</span> android.os.Bundle;</div><div class="line"><span class="keyword">import</span> android.view.View;</div><div class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</div><div class="line"><span class="keyword">import</span> android.widget.Button;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLiteActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="comment">/** Called when the activity is first created. */</span></div><div class="line">  <span class="keyword">private</span> Button button_create,</div><div class="line">          button_upgreate,</div><div class="line">          button_insert,</div><div class="line">          button_up,</div><div class="line">          button_query,</div><div class="line">          button_delete;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.main);</div><div class="line">    button_create = (Button) findViewById(R.id.button1);</div><div class="line">    button_upgreate = (Button) findViewById(R.id.button2);</div><div class="line">    button_insert = (Button) findViewById(R.id.button3);</div><div class="line">    button_up = (Button) findViewById(R.id.button4);</div><div class="line">    button_query = (Button) findViewById(R.id.button5);</div><div class="line">    button_delete = (Button) findViewById(R.id.button6);</div><div class="line">    <span class="comment">//创建数据库</span></div><div class="line">    button_create.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        DataBaseHelpler dbh = <span class="keyword">new</span> DataBaseHelpler(SQLiteActivity.<span class="keyword">this</span>,<span class="string">"tabel_one"</span>);</div><div class="line">        SQLiteDatabase sql = dbh.getReadableDatabase();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//更新数据库</span></div><div class="line">    button_upgreate.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        DataBaseHelpler dbh = <span class="keyword">new</span> DataBaseHelpler(SQLiteActivity.<span class="keyword">this</span>,<span class="string">"tabel_one"</span>,<span class="number">2</span>);</div><div class="line">        SQLiteDatabase sql = dbh.getReadableDatabase();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//向数据库中的表中插入内容</span></div><div class="line">    button_insert.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">        values.put(<span class="string">"no"</span>, <span class="number">123</span>);</div><div class="line">        values.put(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</div><div class="line">        DataBaseHelpler dbh = <span class="keyword">new</span> DataBaseHelpler(SQLiteActivity.<span class="keyword">this</span>,<span class="string">"tabel_one"</span>,<span class="number">2</span>);</div><div class="line">        SQLiteDatabase sql = dbh.getReadableDatabase();</div><div class="line">        <span class="comment">//第三个参数为ContentValues对象，它提供了一系列put()方法重载，用于向ContentValues中添加数据</span></div><div class="line">        <span class="comment">//只需要将表中的每个列名以及相对应的大添加数据传入即可</span></div><div class="line">        sql.insert(<span class="string">"tabel_one"</span>, <span class="keyword">null</span>, values);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//更新表的内容</span></div><div class="line">    button_up.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        DataBaseHelpler dbh = <span class="keyword">new</span> DataBaseHelpler(SQLiteActivity.<span class="keyword">this</span>,<span class="string">"tabel_one"</span>);</div><div class="line">        SQLiteDatabase sql = dbh.getReadableDatabase();</div><div class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">        values.put(<span class="string">"name"</span>, <span class="string">"wangwu"</span>);</div><div class="line">        sql.update(<span class="string">"tabel_one"</span>, values, <span class="string">"id=[]&#123;"</span><span class="number">1</span><span class="string">"&#125;);</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    &#125;);</span></div><div class="line"><span class="string">    //查找表的内容</span></div><div class="line"><span class="string">    button_query.setOnClickListener(new OnClickListener() &#123;</span></div><div class="line"><span class="string">      public void onClick(View v) &#123;</span></div><div class="line"><span class="string">        // TODO Auto-generated method stub</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    &#125;);</span></div><div class="line"><span class="string">    //删除</span></div><div class="line"><span class="string">    button_delete.setOnClickListener(new OnClickListener() &#123;</span></div><div class="line"><span class="string">      public void onClick(View v) &#123;</span></div><div class="line"><span class="string">        // TODO Auto-generated method stub</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    &#125;);</span></div><div class="line"><span class="string">  &#125;</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure>
<h2 id="7-ContentProvider"><a href="#7-ContentProvider" class="headerlink" title="7.ContentProvider"></a>7.ContentProvider</h2><blockquote>
<h2 id="本章转自简书作者Carson-Ho"><a href="#本章转自简书作者Carson-Ho" class="headerlink" title="本章转自简书作者Carson_Ho "></a><strong>本章转自简书作者<a href="http://www.jianshu.com/u/383970bef0a0" target="_blank" rel="external">Carson_Ho</a> </strong></h2></blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><code>ContentProvider</code>属于 <code>Android</code>的四大组件之一</li>
<li>本文全面解析了 <code>ContentProvider</code> ，包括<code>ContentProvider</code> 原理、使用方法 &amp; 实例讲解，希望你们会喜欢。</li>
</ul>
<hr>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="C:/Users/Administrator/Desktop/11.png" alt="11"></p>
<hr>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>即内容提供者，是 <code>Android</code> 四大组件之一</p>
<hr>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>进程间 进行<strong>数据交互 &amp; 共享</strong>，即跨进程通信</p>
<p><img src="C:/Users/Administrator/Desktop/1.png" alt="1"></p>
<hr>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><code>ContentProvider</code>的底层是采用 <code>Android</code>中的<code>Binder</code>机制</li>
<li>具体请看文章<a href="http://www.jianshu.com/p/4ee3fd07da14" target="_blank" rel="external">图文详解 Android Binder跨进程通信的原理</a></li>
</ul>
<hr>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p>关于<code>ContentProvider</code>的使用主要介绍以下内容：</p>
<p><img src="C:/Users/Administrator/Desktop/3.png" alt="3"></p>
<h3 id="7-1-统一资源标识符（URI）"><a href="#7-1-统一资源标识符（URI）" class="headerlink" title="7.1 统一资源标识符（URI）"></a>7.1 统一资源标识符（URI）</h3><ul>
<li><p>定义：<code>Uniform Resource Identifier</code>，即统一资源标识符</p>
</li>
<li><p>作用：唯一标识 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentProvider</div></pre></td></tr></table></figure>
<p> &amp; 其中的数据</p>
<blockquote>
<p>外界进程通过 <code>URI</code> 找到对应的<code>ContentProvider</code>  &amp; 其中的数据，再进行数据操作</p>
</blockquote>
</li>
<li><p>具体使用</p>
<p>​</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">URI</div></pre></td></tr></table></figure>
<p>分为 系统预置 &amp; 自定义，分别对应系统内置的数据（如通讯录、日程表等等）和自定义数据库</p>
<blockquote>
<ol>
<li>关于 系统预置<code>URI</code> 此处不作过多讲解，需要的同学可自行查看</li>
<li>此处主要讲解 自定义<code>URI</code></li>
</ol>
</blockquote>
</li>
</ul>
<p><img src="C:/Users/Administrator/Desktop/4.png" alt="4"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 设置URI</div><div class="line">Uri uri = Uri.parse(&quot;content://com.carson.provider/User/1&quot;) </div><div class="line">// 上述URI指向的资源是：名为 `com.carson.provider`的`ContentProvider` 中表名 为`User` 中的 `id`为1的数据</div><div class="line"></div><div class="line">// 特别注意：URI模式存在匹配通配符* &amp; ＃</div><div class="line"></div><div class="line">// *：匹配任意长度的任何有效字符的字符串</div><div class="line">// 以下的URI 表示 匹配provider的任何内容</div><div class="line">content://com.example.app.provider/* </div><div class="line">// ＃：匹配任意长度的数字字符的字符串</div><div class="line">// 以下的URI 表示 匹配provider中的table表的所有行</div><div class="line">content://com.example.app.provider/table/#</div></pre></td></tr></table></figure>
<h3 id="7-2-MIME数据类型"><a href="#7-2-MIME数据类型" class="headerlink" title="7.2  MIME数据类型"></a>7.2  MIME数据类型</h3><ul>
<li>作用：指定某个扩展名的文件用某种应用程序来打开<br>如指定<code>.html</code>文件采用<code>text</code>应用程序打开、指定<code>.pdf</code>文件采用<code>flash</code>应用程序打开</li>
<li>具体使用：</li>
</ul>
<p><strong>7.2.1 ContentProvider根据 URI 返回MIME类型</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentProvider.geType(uri) ；</div></pre></td></tr></table></figure>
<p><strong>7.2.2 MIME类型组成</strong><br>每种<code>MIME</code>类型 由2部分组成 = 类型 + 子类型</p>
<blockquote>
<p>MIME类型是 一个 包含2部分的字符串</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">text / html</div><div class="line">// 类型 = text、子类型 = html</div><div class="line"></div><div class="line">text/css</div><div class="line">text/xml</div><div class="line">application/pdf</div></pre></td></tr></table></figure>
<p><strong>7.2.3 MIME类型形式</strong><br><code>MIME</code>类型有2种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 形式1：单条记录  </div><div class="line">vnd.android.cursor.item/自定义</div><div class="line">// 形式2：多条记录（集合）</div><div class="line">vnd.android.cursor.dir/自定义 </div><div class="line"></div><div class="line">// 注：</div><div class="line">  // 1. vnd：表示父类型和子类型具有非标准的、特定的形式。</div><div class="line">  // 2. 父类型已固定好（即不能更改），只能区别是单条还是多条记录</div><div class="line">  // 3. 子类型可自定义</div></pre></td></tr></table></figure>
<h4 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;-- 单条记录 --&gt;</div><div class="line">  // 单个记录的MIME类型</div><div class="line">  vnd.android.cursor.item/vnd.yourcompanyname.contenttype </div><div class="line"></div><div class="line">  // 若一个Uri如下</div><div class="line">  content://com.example.transportationprovider/trains/122   </div><div class="line">  // 则ContentProvider会通过ContentProvider.geType(url)返回以下MIME类型</div><div class="line">  vnd.android.cursor.item/vnd.example.rail</div><div class="line"></div><div class="line"></div><div class="line">&lt;-- 多条记录 --&gt;</div><div class="line">  // 多个记录的MIME类型</div><div class="line">  vnd.android.cursor.dir/vnd.yourcompanyname.contenttype </div><div class="line">  // 若一个Uri如下</div><div class="line">  content://com.example.transportationprovider/trains </div><div class="line">  // 则ContentProvider会通过ContentProvider.geType(url)返回以下MIME类型</div><div class="line">  vnd.android.cursor.dir/vnd.example.rail</div></pre></td></tr></table></figure>
<h3 id="7-3-ContentProvider类"><a href="#7-3-ContentProvider类" class="headerlink" title="7.3 ContentProvider类"></a>7.3 ContentProvider类</h3><h4 id="7-3-1-组织数据方式"><a href="#7-3-1-组织数据方式" class="headerlink" title="7.3.1 组织数据方式"></a>7.3.1 组织数据方式</h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentProvider</div></pre></td></tr></table></figure>
<p>主要以 </p>
<p>表格的形式</p>
<p> 组织数据</p>
<blockquote>
<p>同时也支持文件数据，只是表格形式用得比较多</p>
</blockquote>
</li>
<li><p>每个表格中包含多张表，每张表包含行 &amp; 列，分别对应记录 &amp; 字段</p>
<blockquote>
<p>同数据库</p>
</blockquote>
</li>
</ul>
<h4 id="7-3-2-主要方法"><a href="#7-3-2-主要方法" class="headerlink" title="7.3.2 主要方法"></a>7.3.2 主要方法</h4><ul>
<li>进程间共享数据的本质是：添加、删除、获取 &amp; 修改（更新）数据</li>
<li>所以<code>ContentProvider</code>的核心方法也主要是上述4个作用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;-- 4个核心方法 --&gt;</div><div class="line">  public Uri insert(Uri uri, ContentValues values) </div><div class="line">  // 外部进程向 ContentProvider 中添加数据</div><div class="line"></div><div class="line">  public int delete(Uri uri, String selection, String[] selectionArgs) </div><div class="line">  // 外部进程 删除 ContentProvider 中的数据</div><div class="line"></div><div class="line">  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)</div><div class="line">  // 外部进程更新 ContentProvider 中的数据</div><div class="line"></div><div class="line">  public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)　 </div><div class="line">  // 外部应用 获取 ContentProvider 中的数据</div><div class="line"></div><div class="line">// 注：</div><div class="line">  // 1. 上述4个方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</div><div class="line"> // 2. 存在多线程并发访问，需要实现线程同步</div><div class="line">   // a. 若ContentProvider的数据存储方式是使用SQLite &amp; 一个，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</div><div class="line">  // b. 若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</div><div class="line"></div><div class="line">&lt;-- 2个其他方法 --&gt;</div><div class="line">public boolean onCreate() </div><div class="line">// ContentProvider创建后 或 打开系统后其它进程第一次访问该ContentProvider时 由系统进行调用</div><div class="line">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</div><div class="line"></div><div class="line">public String getType(Uri uri)</div><div class="line">// 得到数据类型，即返回当前 Url 所代表数据的MIME类型</div></pre></td></tr></table></figure>
<ul>
<li><p><code>Android</code>为常见的数据（如通讯录、日程表等）提供了内置了默认的<code>ContentProvider</code></p>
</li>
<li><p>但也可根据需求自定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentProvider</div></pre></td></tr></table></figure>
<p>，但上述6个方法必须重写</p>
<blockquote>
<p>本文主要讲解自定义<code>ContentProvider</code></p>
</blockquote>
</li>
<li><p><code>ContentProvider</code>类并不会直接与外部进程交互，而是通过<code>ContentResolver</code> 类</p>
</li>
</ul>
<h3 id="7-4-ContentResolver类"><a href="#7-4-ContentResolver类" class="headerlink" title="7.4 ContentResolver类"></a>7.4 ContentResolver类</h3><h4 id="7-4-1-作用"><a href="#7-4-1-作用" class="headerlink" title="7.4.1 作用"></a>7.4.1 作用</h4><p>统一管理不同 <code>ContentProvider</code>间的操作</p>
<blockquote>
<ol>
<li>即通过 <code>URI</code> 即可操作 不同的<code>ContentProvider</code> 中的数据</li>
<li>外部进程通过 <code>ContentResolver</code>类 从而与<code>ContentProvider</code>类进行交互</li>
</ol>
</blockquote>
<h4 id="7-4-2-为什么要使用通过ContentResolver类从而与ContentProvider类进行交互，而不直接访问ContentProvider类？"><a href="#7-4-2-为什么要使用通过ContentResolver类从而与ContentProvider类进行交互，而不直接访问ContentProvider类？" class="headerlink" title="7.4.2 为什么要使用通过ContentResolver类从而与ContentProvider类进行交互，而不直接访问ContentProvider类？"></a>7.4.2 为什么要使用通过<code>ContentResolver</code>类从而与<code>ContentProvider</code>类进行交互，而不直接访问<code>ContentProvider</code>类？</h4><p>答：</p>
<ul>
<li>一般来说，一款应用要使用多个<code>ContentProvider</code>，若需要了解每个<code>ContentProvider</code>的不同实现从而再完成数据交互，<strong>操作成本高  &amp; 难度大</strong></li>
<li>所以再<code>ContentProvider</code>类上加多了一个 <code>ContentResolver</code>类对所有的<code>ContentProvider</code>进行统一管理。</li>
</ul>
<h4 id="7-4-3-具体使用"><a href="#7-4-3-具体使用" class="headerlink" title="7.4.3 具体使用"></a>7.4.3 具体使用</h4><p><code>ContentResolver</code> 类提供了与<code>ContentProvider</code>类相同名字 &amp; 作用的4个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 外部进程向 ContentProvider 中添加数据</div><div class="line">public Uri insert(Uri uri, ContentValues values)　 </div><div class="line"></div><div class="line">// 外部进程 删除 ContentProvider 中的数据</div><div class="line">public int delete(Uri uri, String selection, String[] selectionArgs)</div><div class="line"></div><div class="line">// 外部进程更新 ContentProvider 中的数据</div><div class="line">public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　 </div><div class="line"></div><div class="line">// 外部应用 获取 ContentProvider 中的数据</div><div class="line">public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</div></pre></td></tr></table></figure>
<ul>
<li>实例说明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 使用ContentResolver前，需要先获取ContentResolver</div><div class="line">// 可通过在所有继承Context的类中 通过调用getContentResolver()来获得ContentResolver</div><div class="line">ContentResolver resolver =  getContentResolver(); </div><div class="line"></div><div class="line">// 设置ContentProvider的URI</div><div class="line">Uri uri = Uri.parse(&quot;content://cn.scu.myprovider/user&quot;); </div><div class="line"></div><div class="line">// 根据URI 操作 ContentProvider中的数据</div><div class="line">// 此处是获取ContentProvider中 user表的所有记录 </div><div class="line">Cursor cursor = resolver.query(uri, null, null, null, &quot;userid desc&quot;);</div></pre></td></tr></table></figure>
<p><code>Android</code> 提供了3个用于辅助<code>ContentProvide</code>的工具类：</p>
<ul>
<li><code>ContentUris</code></li>
<li><code>UriMatcher</code></li>
<li><code>ContentObserver</code></li>
</ul>
<h3 id="7-5-ContentUris类"><a href="#7-5-ContentUris类" class="headerlink" title="7.5 ContentUris类"></a>7.5 ContentUris类</h3><ul>
<li>作用：操作 <code>URI</code></li>
<li>具体使用<br>核心方法有两个：<code>withAppendedId（）</code> &amp;<code>parseId（）</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// withAppendedId（）作用：向URI追加一个id</div><div class="line">Uri uri = Uri.parse(&quot;content://cn.scu.myprovider/user&quot;) </div><div class="line">Uri resultUri = ContentUris.withAppendedId(uri, 7);  </div><div class="line">// 最终生成后的Uri为：content://cn.scu.myprovider/user/7</div><div class="line"></div><div class="line">// parseId（）作用：从URL中获取ID</div><div class="line">Uri uri = Uri.parse(&quot;content://cn.scu.myprovider/user/7&quot;) </div><div class="line">long personid = ContentUris.parseId(uri); </div><div class="line">//获取的结果为:7</div></pre></td></tr></table></figure>
<h3 id="7-6-UriMatcher类"><a href="#7-6-UriMatcher类" class="headerlink" title="7.6 UriMatcher类"></a>7.6 UriMatcher类</h3><ul>
<li>作用<ol>
<li>在<code>ContentProvider</code> 中注册<code>URI</code> </li>
<li>根据 <code>URI</code> 匹配 <code>ContentProvider</code> 中对应的数据表</li>
</ol>
</li>
<li>具体使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 步骤1：初始化UriMatcher对象</div><div class="line">    UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); </div><div class="line">    //常量UriMatcher.NO_MATCH  = 不匹配任何路径的返回码</div><div class="line">    // 即初始化时不匹配任何东西</div><div class="line"></div><div class="line">// 步骤2：在ContentProvider 中注册URI（addURI（））</div><div class="line">    int URI_CODE_a = 1；</div><div class="line">    int URI_CODE_b = 2；</div><div class="line">    matcher.addURI(&quot;cn.scu.myprovider&quot;, &quot;user1&quot;, URI_CODE_a); </div><div class="line">    matcher.addURI(&quot;cn.scu.myprovider&quot;, &quot;user2&quot;, URI_CODE_b); </div><div class="line">    // 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a</div><div class="line">    // 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b</div><div class="line"></div><div class="line">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match（））</div><div class="line"></div><div class="line">@Override   </div><div class="line">    public String getType(Uri uri) &#123;   </div><div class="line">      Uri uri = Uri.parse(&quot; content://cn.scu.myprovider/user1&quot;);   </div><div class="line"></div><div class="line">      switch(matcher.match(uri))&#123;   </div><div class="line">     // 根据URI匹配的返回码是URI_CODE_a</div><div class="line">     // 即matcher.match(uri) == URI_CODE_a</div><div class="line">      case URI_CODE_a:   </div><div class="line">        return tableNameUser1;   </div><div class="line">        // 如果根据URI匹配的返回码是URI_CODE_a，则返回ContentProvider中的名为tableNameUser1的表</div><div class="line">      case URI_CODE_b:   </div><div class="line">        return tableNameUser2;</div><div class="line">        // 如果根据URI匹配的返回码是URI_CODE_b，则返回ContentProvider中的名为tableNameUser2的表</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-7-ContentObserver类"><a href="#7-7-ContentObserver类" class="headerlink" title="7.7 ContentObserver类"></a>7.7 ContentObserver类</h3><ul>
<li><p>定义：内容观察者</p>
</li>
<li><p>作用：观察 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uri</div></pre></td></tr></table></figure>
<p>引起 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentProvider</div></pre></td></tr></table></figure>
<p> 中的数据变化 &amp; 通知外界（即访问该数据访问者）</p>
<blockquote>
<p>当<code>ContentProvider</code> 中的数据发生变化（增、删 &amp; 改）时，就会触发该 <code>ContentObserver</code>类</p>
</blockquote>
</li>
<li><p>具体使用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 步骤1：注册内容观察者ContentObserver</div><div class="line">    getContentResolver().registerContentObserver（uri）；</div><div class="line">    // 通过ContentResolver类进行注册，并指定需要观察的URI</div><div class="line"></div><div class="line">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）</div><div class="line">    public class UserContentProvider extends ContentProvider &#123; </div><div class="line">      public Uri insert(Uri uri, ContentValues values) &#123; </div><div class="line">      db.insert(&quot;user&quot;, &quot;userid&quot;, values); </div><div class="line">      getContext().getContentResolver().notifyChange(uri, null); </div><div class="line">      // 通知访问者</div><div class="line">   &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 步骤3：解除观察者</div><div class="line"> getContentResolver().unregisterContentObserver（uri）；</div><div class="line">    // 同样需要通过ContentResolver类进行解除</div></pre></td></tr></table></figure>
<p>至此，关于<code>ContentProvider</code>的使用已经讲解完毕</p>
<hr>
<h3 id="7-8实例说明"><a href="#7-8实例说明" class="headerlink" title="7. 8实例说明"></a>7. 8实例说明</h3><ul>
<li><p>由于<code>ContentProvider</code>不仅常用于进程间通信，同时也适用于进程内通信</p>
</li>
<li><p>所以本实例会采用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentProvider</div></pre></td></tr></table></figure>
<p>讲解：</p>
<ol>
<li>进程内通信</li>
<li>进程间通信</li>
</ol>
</li>
<li><p>实例说明：采用的数据源是<code>Android</code>中的<code>SQLite</code>数据库</p>
</li>
</ul>
<hr>
<h3 id="7-9-进程内通信"><a href="#7-9-进程内通信" class="headerlink" title="7.9 进程内通信"></a>7.9 进程内通信</h3><ul>
<li>步骤说明：<ol>
<li>创建数据库类</li>
<li>自定义 <code>ContentProvider</code> 类</li>
<li>注册 创建的 <code>ContentProvider</code>类</li>
<li>进程内访问 <code>ContentProvider</code>的数据</li>
</ol>
</li>
<li>具体使用</li>
</ul>
<p><strong>步骤1：创建数据库类</strong><br>关于数据库操作请看文章：<a href="http://www.jianshu.com/p/8e3f294e2828" target="_blank" rel="external">Android：SQLlite数据库操作最详细解析</a></p>
<p><em>DBHelper.java</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class DBHelper extends SQLiteOpenHelper &#123;</div><div class="line"></div><div class="line">    // 数据库名</div><div class="line">    private static final String DATABASE_NAME = &quot;finch.db&quot;;</div><div class="line"></div><div class="line">    // 表名</div><div class="line">    public static final String USER_TABLE_NAME = &quot;user&quot;;</div><div class="line">    public static final String JOB_TABLE_NAME = &quot;job&quot;;</div><div class="line"></div><div class="line">    private static final int DATABASE_VERSION = 1;</div><div class="line">    //数据库版本号</div><div class="line"></div><div class="line">    public DBHelper(Context context) &#123;</div><div class="line">        super(context, DATABASE_NAME, null, DATABASE_VERSION);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(SQLiteDatabase db) &#123;</div><div class="line"></div><div class="line">        // 创建两个表格:用户表 和职业表</div><div class="line">        db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + USER_TABLE_NAME + &quot;(_id INTEGER PRIMARY KEY AUTOINCREMENT,&quot; + &quot; name TEXT)&quot;);</div><div class="line">        db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + JOB_TABLE_NAME + &quot;(_id INTEGER PRIMARY KEY AUTOINCREMENT,&quot; + &quot; job TEXT)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)   &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>步骤2：自定义 ContentProvider 类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line">public class MyProvider extends ContentProvider &#123;</div><div class="line"></div><div class="line">    private Context mContext;</div><div class="line">    DBHelper mDbHelper = null;</div><div class="line">    SQLiteDatabase db = null;</div><div class="line"></div><div class="line">    public static final String AUTOHORITY = &quot;cn.scu.myprovider&quot;;</div><div class="line">    // 设置ContentProvider的唯一标识</div><div class="line"></div><div class="line">    public static final int User_Code = 1;</div><div class="line">    public static final int Job_Code = 2;</div><div class="line"></div><div class="line">    // UriMatcher类使用:在ContentProvider 中注册URI</div><div class="line">    private static final UriMatcher mMatcher;</div><div class="line">    static&#123;</div><div class="line">        mMatcher = new UriMatcher(UriMatcher.NO_MATCH);</div><div class="line">        // 初始化</div><div class="line">        mMatcher.addURI(AUTOHORITY,&quot;user&quot;, User_Code);</div><div class="line">        mMatcher.addURI(AUTOHORITY, &quot;job&quot;, Job_Code);</div><div class="line">        // 若URI资源路径 = content://cn.scu.myprovider/user ，则返回注册码User_Code</div><div class="line">        // 若URI资源路径 = content://cn.scu.myprovider/job ，则返回注册码Job_Code</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 以下是ContentProvider的6个方法</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化ContentProvider</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean onCreate() &#123;</div><div class="line"></div><div class="line">        mContext = getContext();</div><div class="line">        // 在ContentProvider创建时对数据库进行初始化</div><div class="line">        // 运行在主线程，故不能做耗时操作,此处仅作展示</div><div class="line">        mDbHelper = new DBHelper(getContext());</div><div class="line">        db = mDbHelper.getWritableDatabase();</div><div class="line"></div><div class="line">        // 初始化两个表的数据(先清空两个表,再各加入一个记录)</div><div class="line">        db.execSQL(&quot;delete from user&quot;);</div><div class="line">        db.execSQL(&quot;insert into user values(1,&apos;Carson&apos;);&quot;);</div><div class="line">        db.execSQL(&quot;insert into user values(2,&apos;Kobe&apos;);&quot;);</div><div class="line"></div><div class="line">        db.execSQL(&quot;delete from job&quot;);</div><div class="line">        db.execSQL(&quot;insert into job values(1,&apos;Android&apos;);&quot;);</div><div class="line">        db.execSQL(&quot;insert into job values(2,&apos;iOS&apos;);&quot;);</div><div class="line"></div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 添加数据</div><div class="line">     */</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Uri insert(Uri uri, ContentValues values) &#123;</div><div class="line"></div><div class="line">        // 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</div><div class="line">        // 该方法在最下面</div><div class="line">        String table = getTableName(uri);</div><div class="line"></div><div class="line">        // 向该表添加数据</div><div class="line">        db.insert(table, null, values);</div><div class="line"></div><div class="line">        // 当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）</div><div class="line">        mContext.getContentResolver().notifyChange(uri, null);</div><div class="line"></div><div class="line">//        // 通过ContentUris类从URL中获取ID</div><div class="line">//        long personid = ContentUris.parseId(uri);</div><div class="line">//        System.out.println(personid);</div><div class="line"></div><div class="line">        return uri;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 查询数据</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public Cursor query(Uri uri, String[] projection, String selection,</div><div class="line">                        String[] selectionArgs, String sortOrder) &#123;</div><div class="line">        // 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</div><div class="line">        // 该方法在最下面</div><div class="line">        String table = getTableName(uri);</div><div class="line"></div><div class="line">//        // 通过ContentUris类从URL中获取ID</div><div class="line">//        long personid = ContentUris.parseId(uri);</div><div class="line">//        System.out.println(personid);</div><div class="line"></div><div class="line">        // 查询数据</div><div class="line">        return db.query(table,projection,selection,selectionArgs,null,null,sortOrder,null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 更新数据</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int update(Uri uri, ContentValues values, String selection,</div><div class="line">                      String[] selectionArgs) &#123;</div><div class="line">        // 由于不展示,此处不作展开</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 删除数据</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int delete(Uri uri, String selection, String[] selectionArgs) &#123;</div><div class="line">        // 由于不展示,此处不作展开</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getType(Uri uri) &#123;</div><div class="line"></div><div class="line">        // 由于不展示,此处不作展开</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</div><div class="line">     */</div><div class="line">    private String getTableName(Uri uri)&#123;</div><div class="line">        String tableName = null;</div><div class="line">        switch (mMatcher.match(uri)) &#123;</div><div class="line">            case User_Code:</div><div class="line">                tableName = DBHelper.USER_TABLE_NAME;</div><div class="line">                break;</div><div class="line">            case Job_Code:</div><div class="line">                tableName = DBHelper.JOB_TABLE_NAME;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return tableName;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>步骤3：注册 创建的 ContentProvider类</strong><br><em>AndroidManifest.xml</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;provider android:name=&quot;MyProvider&quot;</div><div class="line">                android:authorities=&quot;cn.scu.myprovider&quot;</div><div class="line">                    /&gt;</div></pre></td></tr></table></figure>
<p><strong>步骤4：进程内访问 ContentProvider中的数据</strong></p>
<p><em>MainActivity.java</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 对user表进行操作</div><div class="line">         */</div><div class="line"></div><div class="line">        // 设置URI</div><div class="line">        Uri uri_user = Uri.parse(&quot;content://cn.scu.myprovider/user&quot;);</div><div class="line"></div><div class="line">        // 插入表中数据</div><div class="line">        ContentValues values = new ContentValues();</div><div class="line">        values.put(&quot;_id&quot;, 3);</div><div class="line">        values.put(&quot;name&quot;, &quot;Iverson&quot;);</div><div class="line"></div><div class="line"></div><div class="line">        // 获取ContentResolver</div><div class="line">        ContentResolver resolver =  getContentResolver();</div><div class="line">        // 通过ContentResolver 根据URI 向ContentProvider中插入数据</div><div class="line">        resolver.insert(uri_user,values);</div><div class="line"></div><div class="line">        // 通过ContentResolver 向ContentProvider中查询数据</div><div class="line">        Cursor cursor = resolver.query(uri_user, new String[]&#123;&quot;_id&quot;,&quot;name&quot;&#125;, null, null, null);</div><div class="line">        while (cursor.moveToNext())&#123;</div><div class="line">            System.out.println(&quot;query book:&quot; + cursor.getInt(0) +&quot; &quot;+ cursor.getString(1));</div><div class="line">            // 将表中数据全部输出</div><div class="line">        &#125;</div><div class="line">        cursor.close();</div><div class="line">        // 关闭游标</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 对job表进行操作</div><div class="line">         */</div><div class="line">        // 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</div><div class="line">        Uri uri_job = Uri.parse(&quot;content://cn.scu.myprovider/job&quot;);</div><div class="line"></div><div class="line">        // 插入表中数据</div><div class="line">        ContentValues values2 = new ContentValues();</div><div class="line">        values2.put(&quot;_id&quot;, 3);</div><div class="line">        values2.put(&quot;job&quot;, &quot;NBA Player&quot;);</div><div class="line"></div><div class="line">        // 获取ContentResolver</div><div class="line">        ContentResolver resolver2 =  getContentResolver();</div><div class="line">        // 通过ContentResolver 根据URI 向ContentProvider中插入数据</div><div class="line">        resolver2.insert(uri_job,values2);</div><div class="line"></div><div class="line">        // 通过ContentResolver 向ContentProvider中查询数据</div><div class="line">        Cursor cursor2 = resolver2.query(uri_job, new String[]&#123;&quot;_id&quot;,&quot;job&quot;&#125;, null, null, null);</div><div class="line">        while (cursor2.moveToNext())&#123;</div><div class="line">            System.out.println(&quot;query job:&quot; + cursor2.getInt(0) +&quot; &quot;+ cursor2.getString(1));</div><div class="line">            // 将表中数据全部输出</div><div class="line">        &#125;</div><div class="line">        cursor2.close();</div><div class="line">        // 关闭游标</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="C:/Users/Administrator/Desktop/5.png" alt="5"></p>
<h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p><a href="https://github.com/Carson-Ho/ContentProvider" target="_blank" rel="external">Carson-Ho Github地址：ContentProvider</a></p>
<p>至此，进程内对<code>ContentProvider</code>中的数据进行共享讲解完毕。</p>
<hr>
<h3 id="7-10-进程间进行数据共享"><a href="#7-10-进程间进行数据共享" class="headerlink" title="7.10 进程间进行数据共享"></a>7.10 进程间进行数据共享</h3><ul>
<li>实例说明：本文需要创建2个进程，即创建两个工程，作用如下</li>
</ul>
<p><img src="C:/Users/Administrator/Desktop/6.png" alt="6"></p>
<ul>
<li>具体使用</li>
</ul>
<h3 id="进程1"><a href="#进程1" class="headerlink" title="进程1"></a>进程1</h3><p>使用步骤如下：</p>
<ol>
<li>创建数据库类</li>
<li>自定义 <code>ContentProvider</code> 类</li>
<li>注册 创建的 <code>ContentProvider</code> 类</li>
</ol>
<p>前2个步骤同上例相同，此处不作过多描述，此处主要讲解步骤3.</p>
<p><strong>步骤3：注册 创建的 ContentProvider类</strong><br><em>AndroidManifest.xml</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;provider </div><div class="line">               android:name=&quot;MyProvider&quot;</div><div class="line">               android:authorities=&quot;scut.carson_ho.myprovider&quot;</div><div class="line"></div><div class="line">               // 声明外界进程可访问该Provider的权限（读 &amp; 写）</div><div class="line">               android:permission=&quot;scut.carson_ho.PROVIDER&quot;             </div><div class="line"></div><div class="line">               // 权限可细分为读 &amp; 写的权限</div><div class="line">               // 外界需要声明同样的读 &amp; 写的权限才可进行相应操作，否则会报错</div><div class="line">               // android:readPermisson = &quot;scut.carson_ho.Read&quot;</div><div class="line">               // android:writePermisson = &quot;scut.carson_ho.Write&quot;</div><div class="line"></div><div class="line">               // 设置此provider是否可以被其他进程使用</div><div class="line">               android:exported=&quot;true&quot;</div><div class="line"></div><div class="line">  /&gt;</div><div class="line"></div><div class="line">// 声明本应用 可允许通信的权限</div><div class="line">    &lt;permission android:name=&quot;scut.carson_ho.Read&quot; android:protectionLevel=&quot;normal&quot;/&gt;</div><div class="line">    // 细分读 &amp; 写权限如下，但本Demo直接采用全权限</div><div class="line">    // &lt;permission android:name=&quot;scut.carson_ho.Write&quot; android:protectionLevel=&quot;normal&quot;/&gt;</div><div class="line">    // &lt;permission android:name=&quot;scut.carson_ho.PROVIDER&quot; android:protectionLevel=&quot;normal&quot;/&gt;</div></pre></td></tr></table></figure>
<p>至此，进程1创建完毕，即创建<code>ContentProvider</code> &amp; 数据 准备好了。</p>
<h1 id="源码地址-1"><a href="#源码地址-1" class="headerlink" title="源码地址"></a>源码地址</h1><p><a href="https://github.com/Carson-Ho/ContentProvider" target="_blank" rel="external">Carson-Ho Github地址：ContentProvider1</a></p>
<hr>
<h3 id="进程2"><a href="#进程2" class="headerlink" title="进程2"></a>进程2</h3><p><strong>步骤1：声明可访问的权限</strong></p>
<p><em>AndroidManifest.xml</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    // 声明本应用可允许通信的权限（全权限）</div><div class="line">    &lt;uses-permission android:name=&quot;scut.carson_ho.PROVIDER&quot;/&gt;</div><div class="line"></div><div class="line">    // 细分读 &amp; 写权限如下，但本Demo直接采用全权限</div><div class="line">    // &lt;uses-permission android:name=&quot;scut.carson_ho.Read&quot;/&gt;</div><div class="line">    //  &lt;uses-permission android:name=&quot;scut.carson_ho.Write&quot;/&gt;</div><div class="line"></div><div class="line">// 注：声明的权限必须与进程1中设置的权限对应</div></pre></td></tr></table></figure>
<p><strong>步骤2：访问 ContentProvider的类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 对user表进行操作</div><div class="line">         */</div><div class="line"></div><div class="line">        // 设置URI</div><div class="line">        Uri uri_user = Uri.parse(&quot;content://scut.carson_ho.myprovider/user&quot;);</div><div class="line"></div><div class="line">        // 插入表中数据</div><div class="line">        ContentValues values = new ContentValues();</div><div class="line">        values.put(&quot;_id&quot;, 4);</div><div class="line">        values.put(&quot;name&quot;, &quot;Jordan&quot;);</div><div class="line"></div><div class="line"></div><div class="line">        // 获取ContentResolver</div><div class="line">        ContentResolver resolver =  getContentResolver();</div><div class="line">        // 通过ContentResolver 根据URI 向ContentProvider中插入数据</div><div class="line">        resolver.insert(uri_user,values);</div><div class="line"></div><div class="line">        // 通过ContentResolver 向ContentProvider中查询数据</div><div class="line">        Cursor cursor = resolver.query(uri_user, new String[]&#123;&quot;_id&quot;,&quot;name&quot;&#125;, null, null, null);</div><div class="line">        while (cursor.moveToNext())&#123;</div><div class="line">            System.out.println(&quot;query book:&quot; + cursor.getInt(0) +&quot; &quot;+ cursor.getString(1));</div><div class="line">            // 将表中数据全部输出</div><div class="line">        &#125;</div><div class="line">        cursor.close();</div><div class="line">        // 关闭游标</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 对job表进行操作</div><div class="line">         */</div><div class="line">        // 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</div><div class="line">        Uri uri_job = Uri.parse(&quot;content://scut.carson_ho.myprovider/job&quot;);</div><div class="line"></div><div class="line">        // 插入表中数据</div><div class="line">        ContentValues values2 = new ContentValues();</div><div class="line">        values2.put(&quot;_id&quot;, 4);</div><div class="line">        values2.put(&quot;job&quot;, &quot;NBA Player&quot;);</div><div class="line"></div><div class="line">        // 获取ContentResolver</div><div class="line">        ContentResolver resolver2 =  getContentResolver();</div><div class="line">        // 通过ContentResolver 根据URI 向ContentProvider中插入数据</div><div class="line">        resolver2.insert(uri_job,values2);</div><div class="line"></div><div class="line">        // 通过ContentResolver 向ContentProvider中查询数据</div><div class="line">        Cursor cursor2 = resolver2.query(uri_job, new String[]&#123;&quot;_id&quot;,&quot;job&quot;&#125;, null, null, null);</div><div class="line">        while (cursor2.moveToNext())&#123;</div><div class="line">            System.out.println(&quot;query job:&quot; + cursor2.getInt(0) +&quot; &quot;+ cursor2.getString(1));</div><div class="line">            // 将表中数据全部输出</div><div class="line">        &#125;</div><div class="line">        cursor2.close();</div><div class="line">        // 关闭游标</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，访问<code>ContentProvider</code>数据的进程2创建完毕</p>
<h1 id="源码地址-2"><a href="#源码地址-2" class="headerlink" title="源码地址"></a>源码地址</h1><p><a href="https://github.com/Carson-Ho/ContentProvider2" target="_blank" rel="external">Carson-Ho Github地址：ContentProvider2</a></p>
<hr>
<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p><strong>在进程展示时，需要先运行准备数据的进程1，再运行需要访问数据的进程2</strong></p>
<ol>
<li><p>运行准备数据的进程1<br>在进程1中，我们准备好了一系列数据</p>
<p>​</p>
<p>​</p>
<p><img src="C:/Users/Administrator/Desktop/7.png" alt="7"></p>
<p>​</p>
</li>
<li><p>运行需要访问数据的进程2<br>在进程2中，我们先向<code>ContentProvider</code>中插入数据，再查询数据</p>
</li>
</ol>
<p><img src="C:/Users/Administrator/Desktop/8.png" alt="8"></p>
<p>至此，关于<code>ContentProvider</code>在进程内 &amp; 进程间的使用讲解完毕。</p>
<hr>
<h3 id="7-11-优点"><a href="#7-11-优点" class="headerlink" title="7.11 优点"></a>7.11 优点</h3><ul>
<li>安全</li>
</ul>
<p><code>ContentProvider</code>为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据根据需求开放给 其他应用 进行 <strong>增、删、改、查</strong>，而不用担心因为直接开放数据库权限而带来的安全问题</p>
<ul>
<li>访问简单 &amp; 高效</li>
</ul>
<p>对比于其他对外共享数据的方式，数据访问方式会因数据存储的方式而不同：</p>
<pre><code>- 采用 文件方式 对外共享数据，需要进行文件操作读写数据； 
</code></pre><p>​    - 采用 <code>Sharedpreferences</code> 共享数据，需要使用sharedpreferences API读写数据</p>
<p>这使得访问数据变得复杂 &amp; 难度大。</p>
<p>​    - 而采用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentProvider</div></pre></td></tr></table></figure>
<p>方式，其 解耦了 底层数据的存储方式，使得无论底层数据存储采用何种方式，外界对数据的访问方式都是统一的，这使得</p>
<p>访问简单 &amp; 高效</p>
<blockquote>
<p>如一开始数据存储方式 采用 <code>SQLite</code> 数据库，后来把数据库换成 <code>MongoDB</code>，也不会对上层数据<code>ContentProvider</code>使用代码产生影响</p>
</blockquote>
<p><img src="C:/Users/Administrator/Desktop/9.png" alt="9"></p>
<hr>
<h3 id="7-12-总结"><a href="#7-12-总结" class="headerlink" title="7.12 总结"></a>7.12 总结</h3><ul>
<li>我用一张图总结本文内容</li>
</ul>
<p><img src="C:/Users/Administrator/Desktop/10.png" alt="10"></p>
<ul>
<li><code>ContentProvider</code>的底层是采用 <code>Android</code>中的<code>Binder</code>机制，若想了解请看文章<a href="http://www.jianshu.com/p/4ee3fd07da14" target="_blank" rel="external">图文详解 Android Binder跨进程通信的原理</a></li>
</ul>
<p># </p>
]]></content>
      
        <categories>
            
            <category> -学习 -code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -android </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[ALL tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[notes]]></title>
      <url>/notes/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[分类]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[links]]></title>
      <url>/links/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[pictures]]></title>
      <url>/pictures/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
